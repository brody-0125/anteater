# **The Next-Generation Dart Static Analysis Architecture: Deep Semantic Analysis Engine (DSAE) Technical Specification**

## **1. Introduction: The Evolution of the Dart Language and a Paradigm Shift in Static Analysis**

In modern software engineering, static analysis has become a core infrastructure that guarantees code soundness, security, and maintainability, beyond just catching syntax errors. As the Google-led Dart programming language and Flutter framework emerge as standards for multi-platform development across mobile, web, and desktop, the size and complexity of Dart codebases are increasing exponentially. This change in environment presents new challenges to analysis tools that have relied on syntactic checks and shallow lints.

While the Dart SDK's built-in `package:analyzer` performs excellently, it was inherently designed to support IDEs and act as a compiler frontend. Thus, it shows structural limitations in performing high-level analysis such as deep data flow analysis, value range tracking, and semantic clone detection required by enterprise-grade applications. Particularly, features introduced in Dart 3.0 like patterns, records, and the upcoming macro system for static metaprogramming require much more complex inference processes to understand code meaning.

This technical specification proposes the architecture of the **Deep Semantic Analysis Engine (DSAE)** to meet these requirements. DSAE is designed to overcome the limitations of existing Dart analyzers and perform next-generation static analysis. The engine adopts a hybrid architecture that merges formal methods like abstract interpretation, a relational query system based on Datalog, and neural analysis based on CodeBERT. This allows Dart developers to prevent runtime errors at a mathematically proven level and significantly improve the structural and semantic quality of their code.

This document deeply analyzes the evolution of Dart's internal structures, like the Element model and AST, and details the SSA (Static Single Assignment) conversion algorithm, constraint solving strategies using the Soufflé Datalog engine, and a lightweight AI model inference pipeline via ONNX Runtime.

## ---

**2. In-depth Analysis of Current Dart Analysis Architecture and Technical Limitations**

To design a new engine, it's essential to accurately understand the operating principles and resulting technical bottlenecks of the current analysis infrastructure provided by the Dart SDK. The Dart analyzer essentially parses source code to generate an AST and traverses it to create an Element model.

### **2.1 Evolution of the Element Model: Element2 and Fragment Architecture**

The Element model, the core data structure of the Dart analyzer, represents the semantic reality of code. The initial Element model (V1) was a legacy of the Java implementation, where the concepts of declaration and definition were blurred. This was based on the assumption that logical elements like classes or functions were defined in a single file, an assumption broken by Dart's part-file system and the recent macro system. When a single logical class is declared across multiple files or augmented by a macro, it was difficult for the existing model to represent this accurately.

In response, the Dart team introduced the **Element2** model. The core of this model is the separation of **Element** and **Fragment**. Element2 represents a unique logical entity (e.g., `class User`) across the entire program, while a Fragment represents the physical pieces where the code is declared. For example, the original class declaration written by a developer and an `augment class` declaration generated by a macro become separate Fragments, connected by a doubly linked list called an **Augmentation Chain**. DSAE must be designed based on this Element2 model and must traverse this chain during data flow analysis to correctly identify synthesized members.

### **2.2 The Double Analysis Problem and Plugin System Bottlenecks**

The current Dart Analysis Server (DAS) provides a plugin system for extensibility. However, for stability, it runs each plugin in a separate **Isolate**. Since Dart's Isolates do not share memory, the main analysis server cannot directly pass heavy AST objects or Element models it has already parsed and resolved to the plugins.

This leads to severe inefficiency. Plugins, receiving only the file path and text content, must independently re-parse and re-resolve types. This is known as the **Double Analysis** problem. In large projects (monorepos), this redundant computation for tens of thousands of files leads to a spike in memory usage and wasted CPU resources. Tools like `dart_code_metrics` have historically consumed gigabytes of memory because of this limitation, leading to OOM (Out of Memory) errors. Thus, DSAE must move away from the existing plugin architecture and introduce a new mechanism to run as an independent server process or share analysis results.

### **2.3 Memory Management and Graph Retention**

The Dart analyzer caches inter-file dependency graphs and analysis results for incremental analysis. However, complex reference relationships can hinder garbage collection (GC), causing **Graph Retention** issues. Even after analysis of a specific file is complete, if other files reference its Elements, it is not freed from memory. This causes the memory footprint of a long-running analysis server to continually increase. To solve this, DSAE must adopt an **Ephemeral Analysis Context** strategy: extracting only necessary info into a lightweight database (e.g., Datalog facts) after analysis and immediately releasing heavy AST objects.

## ---

**3. Deep Semantic Analysis Engine (DSAE) Architecture Design**

The goal of DSAE is to extract deep semantic information from Dart source code and perform sophisticated verification. To this end, the engine consists of a 4-stage pipeline: **Frontend**, **IR Builder**, **Semantic Reasoner**, and **Neural Analyzer**.

### **3.1 Hybrid Process Model**

To escape the plugin constraints of the existing Dart Analysis Server, DSAE is designed as a **Standalone Server**. However, to stay integrated with the IDE experience, it communicates via LSP (Language Server Protocol), reusing Dart SDK analysis results (`ResolvedUnitResult`) where possible and only activating its own pipeline when deep analysis is needed.

Particularly, performance-intensive tasks like Datalog-based relation inference and AI model inference are too heavy for the Dart VM. Thus, DSAE actively utilizes **Dart FFI (Foreign Function Interface)** to integrate the **Soufflé** engine (written in C++) and **ONNX Runtime** as in-process components. This eliminates IPC overhead and allows for efficient handling of large data in native memory.

### **3.2 Hierarchical Data Pipeline**

Analysis data is transformed and refined through the following layers:

1. **Source Layer:** Dart source code and `pubspec.yaml` configuration.
2. **Syntactic Layer (Dart Kernel):** Utilizes the kernel binary (`.dill`) generated by the Dart CFE (Common Front End). The kernel format is a desugared, type-explicit high-level IR. Using it as a starting point reduces parsing costs and allows for accurate analysis of code after macros are applied.
3. **Flow Layer (SSA Form):** Generates a Control Flow Graph (CFG) and Static Single Assignment (SSA) form based on the kernel IR. This clarifies the relationship between variable definitions and uses.
4. **Relational Layer (Datalog Facts):** Transforms the SSA graph and type info into normalized tuples (facts) and loads them into the Datalog engine. For example, data flow is represented as `Assign(var1, var2)`.
5. **Neural Layer (Embeddings):** Transforms function bodies into tokenized vector embeddings and stores them in a vector database for similarity searches.

This hierarchical approach optimizes memory efficiency and processing speed by refining only the necessary info at each stage for the next.

## ---

**4. High-Performance Intermediate Representation: SSA Generation Algorithm and Optimization**

The core of deep analysis is tracking where variable values are created and where they flow. For this, DSAE adopts **Static Single Assignment (SSA)** as its internal IR. SSA is a form where every variable is assigned exactly once, drastically simplifying data flow analysis. Since the Dart Analyzer doesn't provide a public SSA generation API, DSAE must include its own SSA generator.

### **4.1 Braun et al.'s Direct AST-to-SSA Conversion Algorithm**

Traditional SSA generation (Cytron et al.) involves a complex process of building a CFG, calculating the dominator tree and dominance frontier, and then placing Phi ($\phi$) functions. This is computationally expensive and hard to implement. DSAE adopts the algorithm proposed by **Braun et al. (2013)**. This algorithm generates SSA on-the-fly while traversing the AST without dominator analysis, making it highly efficient.

#### **4.1.1 Algorithm Specification**

The Braun algorithm consists of two stages: **Local Value Numbering** and **Global Value Numbering**.

1. **Intra-block Variable Tracking (CurrentDef Management):**
   Maintains a `CurrentDef` map for each basic block, using variables as keys and their latest definitions (values) as values.
   * `writeVariable(variable, block, value)`: Updates the `CurrentDef` of the block.
   * `readVariable(variable, block)`: Looks up the value in `CurrentDef`. If not found, it starts a **Recursive Lookup**.
2. **Recursive Lookup and Lazy Phi Insertion:**
   If a variable is not defined in the current block, it searches predecessors.
   * **Single predecessor:** Recursively calls `readVariable` on that predecessor.
   * **Multiple predecessors:** This is a merge point. It creates a **Phi function** ($\phi$). Crucially, to prevent infinite recursion (loops), it first registers a $\phi$ with undetermined operands in `CurrentDef` and then fills the operands by calling `readVariable` on each predecessor.
3. **Trivial Phi Elimination:**
   If all operands of a $\phi$ function are itself or a single unique value, the $\phi$ is unnecessary. It's replaced with that unique value and removed from the graph. This can be done immediately during SSA generation or as a separate pass.

### **4.2 Dart-Specific Control Flow Handling Guidelines**

Special handling is required to represent unique Dart features in SSA.

* **Asynchronous Flow (Async/Await):** The `await` keyword suspends function execution and resumes when the `Future` completes. In terms of CFG, an `await` expression terminates the current block, and subsequent code is linked as a successor block. DSAE models `await` points as explicit **Control Flow Splits** to track state changes before and after asynchronous tasks.
* **Exception Handling (Try-Catch-Finally):** Function calls or `throw` statements within a `try` block can move control flow to a `catch` block at any time. Thus, all potential exception points in a `try` block must have edges pointing to the start of the `catch` block. In SSA, the exception object in the `catch` block is treated as a new definition, like an incoming parameter.
* **Type Promotion:** Dart's `is` checks or null checks make variable types more specific. To reflect this in SSA, **Filter** or **Pi ($\pi$)** nodes are inserted at the start of branched blocks. For example, in the True branch of `if (x is String)`, a virtual command like `x_2 = Filter(x_1, String)` specifies that `x` is `String`, and subsequent code is renamed to use `x_2`.

| Dart Feature | SSA Modeling Strategy |
| :---- | :---- |
| **Null-aware operators (?., ??)** | Internally transformed to conditional branches. `lhs ?? rhs` generates a diamond-shaped CFG with an `lhs != null` check. |
| **Cascade (..)** | Introduces a temporary variable to maintain the receiver object, transforming consecutive method calls into calls on that variable. |
| **Closure** | Access to captured variables is modeled as heap access, or deep analysis is performed to link data flow edges into the closure definition. |

## ---

**5. Relational Reasoning Engine: Integrating Datalog and Soufflé**

Once the SSA form is ready, DSAE performs **Datalog-based relational reasoning** to verify complex program properties. Datalog is a declarative logic programming language excellent for representing and solving recursive relationships in program analysis, such as reachability and pointer analysis. DSAE integrates the high-performance Datalog engine **Soufflé** for this.

### **5.1 Soufflé Integration and FFI Bridge Design**

Soufflé compiles Datalog rules into highly optimized C++ code. DSAE calls compiled C++ libraries directly via Dart FFI. This method is much faster than passing serialized data to an external process and allows for the direct exchange of large fact datasets in memory.

**Integration Process:**

1. **Rule Definition:** Write Datalog rules (`.dl` files) modeling the semantics of the Dart language.
2. **Engine Compilation:** Use the Soufflé compiler to transform rules into C++ source and build it as a shared library (`.so`, `.dll`). Use the `__EMBEDDED_SOUFFLE__` flag for embedded mode.
3. **Data Loading:** Call the C++ API from the Dart side using `package:ffi`. Load SSA analysis results (nodes, edges, variables, etc.) into relational tables via methods like `souffle::SouffleProgram::loadAll`.
4. **Execution and Results Query:** Call `run()` for fixpoint calculation and mapping results back to Dart objects by traversing result relations.

### **5.2 Data Schema and Analysis Rules (EDB & IDB)**

A normalized data schema is essential for efficient analysis.

**EDB (Extensional Database - Input Facts):**
* `Assign(var_id: number, expr_id: number)`: Variable assignment relationship.
* `Flow(block_from: number, block_to: number)`: Control flow edge.
* `LoadField(base_var: number, field_name: symbol, target_var: number)`: Field read.
* `StoreField(base_var: number, field_name: symbol, source_var: number)`: Field write.
* `Alloc(var_id: number, type: symbol)`: Object allocation.

**IDB (Intensional Database - Inference Rules):**
The most representative Points-to Analysis rules can be defined as follows:

```prolog
// Rule 1: On object creation, variable points to the object
VarPointsTo(var, heap) :- Assign(var, alloc), Alloc(alloc, heap).

// Rule 2: Assignment between variables (Copy)
VarPointsTo(var1, heap) :- Assign(var1, var2), VarPointsTo(var2, heap).

// Rule 3: Field store - Connect base object's field to the source object
HeapPointsTo(baseHeap, field, targetHeap) :-
    StoreField(base, field, source),
    VarPointsTo(base, baseHeap),
    VarPointsTo(source, targetHeap).

// Rule 4: Field load - Variable points to the object in the field of the base object
VarPointsTo(target, targetHeap) :-
    LoadField(base, field, target),
    VarPointsTo(base, baseHeap),
    HeapPointsTo(baseHeap, field, targetHeap).
```

These rules are automatically transformed into optimized loops and join operations by the Soufflé engine. This allows DSAE to quickly and accurately calculate the set of objects a variable can point to, even in millions of lines of code.

### **5.3 Verifying Immutability and Purity**

Utilizing Datalog's reachability queries, **Deep Immutability** can be verified. While Dart's `final` only guarantees shallow immutability (no reference change), DSAE can trace the object graph to check if all objects connected to the target are immutable.

* **Rule:** An object is 'mutable' if a `StoreField` occurs on it or if it references a mutable object in its fields.
* **Query:** Guarantees deep immutability by proving the target doesn't belong to the 'mutable' set. This plays a key role in ensuring safety in multi-threaded or functional programming patterns.

## ---

**6. Abstract Interpretation and Numerical Verification**

While Datalog analyzes relational properties, **Abstract Interpretation** is used to mathematically approximate the range of values a program variable can take to prove the absence of runtime errors. DSAE implements the interval analysis domain, specifically to detect out-of-bounds array access or integer overflows.

### **6.1 Abstract Domains and Lattice Theory**

Abstract interpretation maps a set of concrete values to an abstract domain for calculation.

* **Interval Domain:** Maintains an interval `[min, max]` for each variable $x$, where $min, max \in \mathbb{Z} \cup \{-\infty, +\infty\}$. This domain forms a complete lattice, with the inclusion relation defined by interval inclusion.
  * Abstraction function $\alpha$: Maps to the smallest interval containing the set of integers.
  * Concretization function $\gamma$: Maps to the set of all integers within the interval.
* **Octagon Domain:** Tracks not only simple intervals but also relationships between two variables, specifically inequalities like $\pm x \pm y \le c$. This is essential for proving the relationship ($i < n$) between an array index $i$ and length $n$. It is more precise but computationally more expensive ($O(n^3)$), so it's selectively applied to variables related to loop indices and array access.

### **6.2 Widening and Narrowing Operators**

When analyzing programs with loops, the **Fixpoint Iteration** technique is used to prevent intervals from growing infinitely. To guarantee the convergence speed, the **Widening ($\nabla$)** operator is used.

1. **Widening Algorithm:** If an upper or lower bound of an interval expands during iteration, it's immediately expanded to infinity ($+\infty$ or $-\infty$). For example, if $i$ in a loop increases as $0, 1, 2, \dots$, the widening operator approximates this as $[0, +\infty]$ and stops the iteration.
2. **Narrowing Algorithm:** If widening results in an overly broad range (over-approximation), the **Narrowing ($\Delta$)** operation is performed to restore accuracy. This process reduces the infinite range back to a finite range (e.g., $[0, 9]$) using the loop condition (e.g., $i < 10$).

### **6.3 Case: Array Bounds Check Elimination**

DSAE verifies code like the following via abstract interpretation:

```dart
for (var i = 0; i < list.length; i++) {
  print(list[i]);
}
```

1. **Analysis:** The loop invariant is derived as $0 \le i < list.length$.
2. **Verification:** Proves in the abstract domain that the required conditions for `list[i]` access ($0 \le i$ and $i < list.length$) are 'Always True' within the loop.
3. **Result:** Since the access is safe, it hints the compiler to remove runtime bounds check code or generates a report guaranteeing the user of its safety.

## ---

**7. Neuro-Symbolic Integration: Semantic Analysis based on CodeBERT**

To detect 'code smells' that formal methods can't catch, or **Type-4 Clones** (same logic, different syntax), DSAE integrates AI models into its pipeline.

### **7.1 Lightweight Models based on Knowledge Distillation**

Large language models (LLMs) like CodeBERT are too heavy to run in a local analysis environment. DSAE uses a student model that significantly reduces size while maintaining performance via **Knowledge Distillation**.

* **Teacher Model:** CodeT5 or CodeBERT-base.
* **Student Model:** DistilBERT architecture (6 layers, ~66 million parameters).
* **Training Strategy:** Trained on a Dart code corpus to minimize the Kullback-Leibler (KL) divergence between the teacher's soft logits and the student's output. This allows the student model to mimic the teacher's language understanding while being over 60% faster in inference and saving over 40% memory.

### **7.2 High-Speed Inference via ONNX Runtime**

The trained model is converted to the **ONNX (Open Neural Network Exchange)** format to remove PyTorch dependencies. DSAE loads and executes the ONNX model via `package:onnxruntime_v2`.

* **Tokenization:** A WordPiece tokenizer is implemented directly in Dart for model input preprocessing, allowing text-to-tensor conversion without a Python runtime.
* **Vectorization and Search:** Each function or method passes through the model to generate a 768-dimensional dense vector (embedding). These vectors are indexed in a local vector store (e.g., a lightweight version of FAISS or a KD-tree), enabling fast searches for semantically similar code via cosine similarity calculations. Code pairs with a similarity of 0.85 or higher are reported as potential duplicates.

## ---

**8. Advancing Code Quality Metric Algorithms**

Beyond qualitative analysis, DSAE provides quantitative code quality metrics. It inherits DCM's metrics but improves the algorithms to reflect Dart-specific features more precisely.

* **Cyclomatic Complexity:** Instead of just counting keywords, weights are assigned to Dart's null-aware operators (`?.`, `??`) as they are treated as branches. Conversely, the `await` keyword is excluded from the score to avoid unnecessary penalties for asynchronous code, as it's an asynchronous flow rather than a logical branch.
* **Maintainability Index:**
  $$MI = \max(0, (171 - 5.2 \ln(V) - 0.23 G - 16.2 \ln(LOC)) \times 100 / 171)$$
  Where $V$ is Halstead Volume, $G$ is cyclomatic complexity, and $LOC$ is lines of code. DSAE calculates all these metrics with a single AST traversal during SSA generation, minimizing overhead.

## ---

**9. Feasibility and Implementation Guidelines**

A step-by-step approach and performance optimization are essential for the successful implementation of this architecture.

### **9.1 Performance and Memory Optimization Strategies**

* **Sharded Cache:** Analysis result caches are sharded by package or directory to reduce lock contention during parallel processing and enable partial cache invalidation.
* **Ephemeral Context:** AST objects are immediately freed from memory after extracting necessary info (Datalog facts, etc.), preventing the chronic memory leak issues of the Dart Analyzer.
* **Parallel Processing:** Since the Datalog engine (Soufflé) supports parallel execution via OpenMP, large-scale relational operations can be accelerated by fully utilizing multi-core CPUs.

### **9.2 Migration and Compatibility**

* **Macro Compatibility:** DSAE must analyze code after macro expansions (Augmented Code). It should take kernel binaries from CFE as input or subscribe to results after the Analyzer's resolve stage.
* **LSP Integration:** To work with IDEs, it must comply with LSP standards and respect user rules defined in `analysis_options.yaml`.

## **10. Conclusion**

The proposed Deep Semantic Analysis Engine (DSAE) is a platform that understands Dart code mathematically and logically, moving beyond a simple linter. The combination of precise data flow tracking via SSA, relational proof via Datalog, and semantic pattern recognition via AI will leapfrog the software quality in the Dart ecosystem. Particularly, the integration of a high-performance native engine through FFI and efficient IR generation via the Braun algorithm suggests that this architecture can operate in real-time in actual development environments, beyond a theoretical concept. This will contribute to establishing Dart as a reliable language even for mission-critical systems, surpassing its status as a simple app development language.

---

**Data Sources Used:**
1 (Dart/DCM structure and limitations)
7 (SSA generation algorithm)
5 (Datalog and Soufflé)
17 (Abstract interpretation and numerical domains)
9 (AI models and ONNX)
4 (Implementation tools and formats)

#### **References**

1. Dart Analyzer Structure, Operation, Functions, and Limitations
2. Analysis of Dart Analyzer and DCM Algorithms
3. In-depth Survey of Dart Code Metric Analysis
4. Using FFI in a Flutter plugin | Google Codelabs, accessed Dec 26, 2025, [https://codelabs.developers.google.com/codelabs/flutter-ffigen](https://codelabs.developers.google.com/codelabs/flutter-ffigen)
5. C++ Interface | Soufflé • A Datalog Synthesis Tool for Static Analysis, accessed Dec 26, 2025, [https://souffle-lang.github.io/interface](https://souffle-lang.github.io/interface)
6. dart-archive/kernel: Dart IR (Intermediate Representation) - GitHub, accessed Dec 26, 2025, [https://github.com/dart-archive/kernel](https://github.com/dart-archive/kernel)
7. Simple and Efficient Construction of Static Single Assignment Form, accessed Dec 26, 2025, [https://www.cs.cornell.edu/courses/cs6120/2025sp/blog/efficient-ssa/](https://www.cs.cornell.edu/courses/cs6120/2025sp/blog/efficient-ssa/)
8. Specialized Static Analysis Framework: Datalog Analysis, accessed Dec 26, 2025, [https://psl.hanyang.ac.kr/~wslee/courses/cse6049/lecture11.pdf](https://psl.hanyang.ac.kr/~wslee/courses/cse6049/lecture11.pdf)
9. CodeBERT for code clone detection: A replication study, accessed Dec 26, 2025, [https://ink.library.smu.edu.sg/cgi/viewcontent.cgi?article=11175&context=sis_research](https://ink.library.smu.edu.sg/cgi/viewcontent.cgi?article=11175&context=sis_research)
10. Static single-assignment form - Wikipedia, accessed Dec 26, 2025, [https://en.wikipedia.org/wiki/Static_single-assignment_form](https://en.wikipedia.org/wiki/Static_single-assignment_form)
11. PA4: SSA - ITP 439, accessed Dec 26, 2025, [https://itp439-20231.github.io/PA4.html](https://itp439-20231.github.io/PA4.html)
12. Simple and Efficient Construction of Static Single Assignment Form, accessed Dec 26, 2025, [https://www.semanticscholar.org/paper/Simple-and-Efficient-Construction-of-Static-Single-Braun-Buchwald/de39bd5bf447cf40e5dd8f5141fedc6a901cfaef](https://www.semanticscholar.org/paper/Simple-and-Efficient-Construction-of-Static-Single-Braun-Buchwald/de39bd5bf447cf40e5dd8f5141fedc6a901cfaef)
13. Simple and Efficient SSA Construction - c9x.me, accessed Dec 26, 2025, [https://c9x.me/compile/bib/braun13cc.pdf](https://c9x.me/compile/bib/braun13cc.pdf)
14. control_flow_graph | Dart package - Pub.dev, accessed Dec 26, 2025, [https://pub.dev/packages/control_flow_graph](https://pub.dev/packages/control_flow_graph)
15. Java program analysis using the Datalog Solve tool. - ResearchGate, accessed Dec 26, 2025, [https://www.researchgate.net/figure/Java-program-analysis-using-the-Datalog-Solve-tool_fig1_221313290](https://www.researchgate.net/figure/Java-program-analysis-using-the-Datalog-Solve-tool_fig1_221313290)
16. Using Datalog for Fast and Easy Program Analysis, accessed Dec 26, 2025, [https://yanniss.github.io/doop-datalog2.0.pdf](https://yanniss.github.io/doop-datalog2.0.pdf)
17. Abstract interpretation - Wikipedia, accessed Dec 26, 2025, [https://en.wikipedia.org/wiki/Abstract_interpretation](https://en.wikipedia.org/wiki/Abstract_interpretation)
18. Abstract Interpretation II, accessed Dec 26, 2025, [https://www.di.ens.fr/~rival/semverif-2015/sem-11-ai.pdf](https://www.di.ens.fr/~rival/semverif-2015/sem-11-ai.pdf)
19. Abstract interpretation, accessed Dec 26, 2025, [https://www.cl.cam.ac.uk/teaching/2425/R277/slides-abstract-interpretation.pdf](https://www.cl.cam.ac.uk/teaching/2425/R277/slides-abstract-interpretation.pdf)
20. Widening and narrowing operators for abstract interpretation, accessed Dec 26, 2025, [https://scispace.com/pdf/widening-and-narrowing-operators-for-abstract-interpretation-3tkyyt9su0.pdf](https://scispace.com/pdf/widening-and-narrowing-operators-for-abstract-interpretation-3tkyyt9su0.pdf)
21. Narrowing operators on template abstract domains, accessed Dec 26, 2025, [https://www.sci.unich.it/~amato/papers/fm15.pdf](https://www.sci.unich.it/~amato/papers/fm15.pdf)
22. Checking Array Bounds by Abstract Interpretation and Symbolic ..., accessed Dec 26, 2025, [https://www.researchgate.net/publication/326073330_Checking_Array_Bounds_by_Abstract_Interpretation_and_Symbolic_Expressions](https://www.researchgate.net/publication/326073330_Checking_Array_Bounds_by_Abstract_Interpretation_and_Symbolic_Expressions)
23. Distilbert: A Smaller, Faster, and Distilled BERT - Zilliz Learn, accessed Dec 26, 2025, [https://zilliz.com/learn/distilbert-distilled-version-of-bert](https://zilliz.com/learn/distilbert-distilled-version-of-bert)
24. A Comparative Study of Knowledge Distillation from CodeT5, accessed Dec 26, 2025, [https://repository.tudelft.nl/file/File_c8c047fb-2bb7-4699-addd-57e75cc2e48b?preview=1](https://repository.tudelft.nl/file/File_c8c047fb-2bb7-4699-addd-57e75cc2e48b?preview=1)
25. Large Language Models: DistilBERT - Smaller, Faster, Cheaper and ..., accessed Dec 26, 2025, [https://towardsdatascience.com/distilbert-11c8810d29fc/](https://towardsdatascience.com/distilbert-11c8810d29fc/)
26. onnxruntime_v2 | Flutter package - Pub.dev, accessed Dec 26, 2025, [https://pub.dev/packages/onnxruntime_v2](https://pub.dev/packages/onnxruntime_v2)
27. distilbert/distilbert-base-uncased - Hugging Face, accessed Dec 26, 2025, [https://huggingface.co/distilbert/distilbert-base-uncased](https://huggingface.co/distilbert/distilbert-base-uncased)
28. CodeBERT for Code Clone Detection: A Replication Study, accessed Dec 26, 2025, [https://www.researchgate.net/publication/366277960_CodeBERT_for_Code_Clone_Detection_A_Replication_Study](https://www.researchgate.net/publication/366277960_CodeBERT_for_Code_Clone_Detection_A_Replication_Study)
29. Efficient Abstract Interpretation via Selective Widening, accessed Dec 26, 2025, [https://research-management.mq.edu.au/ws/portalfiles/portal/466699902/466699559.pdf](https://research-management.mq.edu.au/ws/portalfiles/portal/466699902/466699559.pdf)
30. Customizing static analysis - Dart, accessed Dec 26, 2025, [https://dart.dev/tools/analysis](https://dart.dev/tools/analysis)
31. Program Repair Guided by Datalog-Defined Static Analysis, accessed Dec 26, 2025, [https://discovery.ucl.ac.uk/id/eprint/10184117/1/Mechtaev_Program%20Repair%20Guided%20by%20Datalog-Defined%20Static.pdf](https://discovery.ucl.ac.uk/id/eprint/10184117/1/Mechtaev_Program%20Repair%20Guided%20by%20Datalog-Defined%20Static.pdf)
32. Object-Oriented Fixpoint Programming with Datalog, accessed Dec 26, 2025, [https://www.pl.informatik.uni-mainz.de/files/2024/10/datalog-oop.pdf](https://www.pl.informatik.uni-mainz.de/files/2024/10/datalog-oop.pdf)
33. Abstract Interpretation Based Program Testing, accessed Dec 26, 2025, [https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-SSGRR-00.pdf](https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-SSGRR-00.pdf)
34. [2208.12588] Generalizability of Code Clone Detection on CodeBERT, accessed Dec 26, 2025, [https://arxiv.org/abs/2208.12588](https://arxiv.org/abs/2208.12588)
